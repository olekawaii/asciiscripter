ASCR is pure functional programming language for making ascii art animations

check out some examples in the examples/ directory.

things left to implement:

[ ]  generics
[ ]  higher kinded types
[ ]  type classes
[ ]  syntax for frame variables in art


Comments
====================

    .----------------------------------------------------------.
    | -- this is a comment                                     |
    |                                                          |
    | this is not  -- this is                                  |
    |                                                          |
    | ---                                                      |
    | long                                                     |
    | multi-line                                               |
    | comment                                                  |
    | <o>                                                      |
    |                                                          |
    | define bottom_of_triangle of_type video as art viii ii   |
    | --    /\   ...33...                                      |
    | --   /  \  ..3//3..                                      |
    |  /    \ .3////3.                                         |
    | /______\33333333                                         |
    |                                                          |
    | define flag of_type video as art vii iii                 |
    | -------3333333                                           |
    | -- * --33/3/33 not a comment                             |
    | -------3333333                                           |
    '----------------------------------------------------------'


Expression Syntax
====================

An expression is either a lambda, a match, or an argument tree.

lambda expression
--------------------

All branches must have the same indentation. The mandetory keywords are
'match', 'in', and 'to'.

    .----------------------------------------------------------.
    | 'match' <expression> 'in'                                |
    |    constructor arg ... 'to' <expression>                 |
    |    ...                                                   |
    '----------------------------------------------------------'

lambda expression
--------------------
    .----------------------------------------------------------.
    | 'lambda' arg 'dot' <expression>                          |
    '----------------------------------------------------------'

argument tree
--------------------
  1 .----------------------------------------------------------.
    | root word word ... <expression>?                         |
    '----------------------------------------------------------'

sum(v, product(iii, x)) (in C syntax) as an argument tree would be

    .----------------------------------------------------------.
    | sum v product iii x                                      |
    '----------------------------------------------------------'

This is possible because the types of all variables are known at compile-time,
letting us use polish notation to group them into expressions

  2 .----------------------------------------------------------.
    | root                                                     |
    |    <expression>                                          |
    |    <expression>                                          |
    |    ...                                                   |
    '----------------------------------------------------------'

With the second syntax every argument of the root must be on its own line 
with the correct indentation. This the only way to use a lambda or match
expresion directly as an argument.


ALGEBRAIC TYPES
====================

    .----------------------------------------------------------.
    | data bool contains                                       |
    |    true                                                  |
    |    false                                                 |
    |                                                          |
    | data list_of_bools contains                              |
    |    empty_list                                            |
    |    prepend bool list_of_bools                            |
    |                                                          |
    | data maybe_bool contains                                 |
    |    none                                                  |
    |    some bool                                             |
    |                                                          |
    | define head of_type fn list_of_bools maybe_bool as       |
    |    lambda input_list dot match input_list in             |
    |       empty_list to none                                 |
    |       prepend head tail to some head                     |
    '----------------------------------------------------------'

    .----------------------------------------------------------.
    | define main of_type maybe_bool as                        |
    |    head prepend true prepend false empty_list            |
    '----------------------------------------------------------'
    output: some true

    .----------------------------------------------------------.
    | define main of_type maybe_bool as                        |
    |    head empty_list                                       |
    '----------------------------------------------------------'
    output: none



RECURSION
====================

There are no loops. The only way to 'loop' is to use recursion.

    .----------------------------------------------------------.
    | define main of_type bool as                              |
    |    sum                                                   '
    |       succ succ one                    .----------------------.
    |       succ one                         | one              = 1 |
    |                                        | succ one         = 2 |
    | data nat contains                      | succ (succ one)  = 3 |
    |    one                                 | and so on            |
    |    succ nat                            '----------------------'
    |                                                          .
    | define sum of_type fn nat fn nat nat as                  |
    |    lambda x dot match x in                               |
    |       one to succ                                        |
    |       succ pred_x to                                     |
    |          lambda y dot succ sum pred_x y                  |
    '----------------------------------------------------------'
     output: succ succ succ succ one



LAZY EVALUATION
====================

The whole language is lazily evaluated. The only thing evaluated strictly
is the main function.

Here are some examples. Expressions are only evaluated when patternmatched on.
If you don't try to match on something, it will never be evaluated.
To evaluate an expression, it is rewritten until it starts with a
data constructor.

    .----------------------------------------------------------.
    | define is_equal of_type fn nat fn nat bool as            |
    |    lambda x dot lambda y dot match x in                  |
    |       one to match y in                                  |
    |          one to true                                     |
    |          succ _ to false                                 |
    |       succ pred_x to match y in                          |
    |          one to false                                    |
    |          succ pred_y to                                  |
    |             is_equal pred_x pred_y                       |
    '----------------------------------------------------------'

    .----------------------------------------------------------.
    | define main of_type bool as                              |
    |    is_equal                                              |
    |       succ succ one                                      |
    |       succ succ one                                      |
    '----------------------------------------------------------'
    output: true

    .----------------------------------------------------------.
    | define main of_type bool as                              |
    |    is_equal                                              |
    |       succ succ one                                      |
    |       succ succ succ one                                 |
    '----------------------------------------------------------'
    output: false

    .----------------------------------------------------------.
    | define main of_type bool as                              |
    |    is_equal                                              |
    |       succ succ succ one                                 |
    |       infinity                                           |
    |                                                          |
    | define infinity of_type nat as succ infinity             |
    '----------------------------------------------------------'
     output: false

    .----------------------------------------------------------.
    | define main of_type bool as                              |
    |    is_equal infinity infinity                            |
    '----------------------------------------------------------'
     output: *hangs at runtime*
                                                 .---------------.
    .------------------------------------------- | ... is syntax |
    | define main of_type bool as                | for undefined |
    |    is_equal                                '---------------'
    |       succ succ succ one                                 .
    |       succ succ succ succ succ ...                       |
    '----------------------------------------------------------'
    output: false
                                                                  
    .----------------------------------------------------------.  
    | define main of_type bool as                              |  
    |    is_equal                                              |  
    |       succ succ succ one                                 |
    |       succ succ ...                                      |
    '----------------------------------------------------------'
    output: *panics at runtime*


UNDEFINED
====================

Undefined expressions panic at runtime if you attempt to evaluate them.
They are useful for unimplemented or unreachable code

    .----------------------------------------------------------.
    | define main of_type video as ...                         |
    '----------------------------------------------------------'


ART
====================

This code defines an animation of a swinging tail. The animation is 6x4 in
size and has 2 frames.

    .----------------------------------------------------------.
    | define dragon_tail of_type video as art vi iv            |
    |  \   ).6///6(   / 6///6.                                 |
    |   ) / ..6/6. \ (  .6/6..                                 |
    |  ( /  .6/6..  \ ) ..6/6.                                 |
    |   V   ..6...   V  ...6..                                 |
    '----------------------------------------------------------'

The art macro is expanded into regular code during the tokenization phase.

Every frame is made up of who rectangles, one with the ascii art and the 
other with the corresponding colors. Colors 0-7 correspond to ansi colors
black-white, '.' marks transparency, and '/' marks a space.

There is also special syntax for including local/global variables in the
art. 

To use a color variable you just have to replace the number with the variable
name like so:

    .----------------------------------------------------------.
    | define dragon_tail of_type fn color video as             |
    |    lambda c dot art vi iv                                |
    |  \   ).c///c(   / c///c.                                 |
    |   ) / ..c/c. \ (  .c/c..                                 |
    |  ( /  .c/c..  \ ) ..c/c.                                 |
    |   V   ..c...   V  ...c..                                 |
    '----------------------------------------------------------'

Now instead of the tail being hardcoded cyan, the calling function decides
its color.

To include a variable character, set the color to '$' and use the variable 
name in the art section.

you can have a custom tail tip for example:

    .----------------------------------------------------------.
    | define dragon_tail of_type fn character video as         |
    |    lambda t dot art vi iv                                |
    |  \   ).6///6(   / 6///6.                                 |
    |   ) / ..6/6. \ (  .6/6..                                 |
    |  ( /  .6/6..  \ ) ..6/6.                                 |
    |   t   ..$...   t  ...$..                                 |
    '----------------------------------------------------------'

You can see how the video type is implemented in the core module and there are
many useful functions in std.


OUTPUT
====================

After compiling/running the program, the output is the fully-evaluated main
function (a tree of data constructors). In fact, if you plug the output into 
the main function, you will get the same output. To turn this output into 
something you actually want, you have to interpret it with an external 
program (like ascr-to-shell for ascii art animations for example).
